namespace ca.mcgill.ecse223.tileo.model;

class TileO {
  1 <@>- * Game games;
  1 -> 0..1 Game currentGame;
}

class Game {
  mode { DESIGN{} GAME{} GAME_WON{} GAME_ROLLDIEACTIONCARD{} GAME_CONNECTTILESACTIONCARD{} GAME_REMOVECONNECTIONACTIONCARD{} GAME_TELEPORTACTIONCARD{} GAME_LOSETURNACTIONCARD{} }
  1 <@>- 2..4 Player players;
  1 <@>- * Tile tiles;
  1 <@>- * Connection connections;
  1 <@>- 1 Deck deck;
  1 <@>- 1 Die die;
  1 -> 0..1 Player currentPlayer;
  1 -> 0..1 WinTile winTile;
  const Integer SpareConnectionPieces = 32;
  Integer currentConnectionPieces;
  const Integer NumberOfActionCards = 32;
  
	public ArrayList<Tile> rollDie() {
		// List of tiles to return that represents possible moves
		ArrayList<Tile> tiles = new ArrayList<Tile>();
		// 'this' is the game
		Die die = this.getDie();

		// roll the die
		int dieValue = die.roll();
		
		// Get the current player
		Player currentPlayer = this.getCurrentPlayer();

		//TODO Check getPossibleMoves is implemented
		// Tiles is a list of possible moves the current player can make based
		// on their die role
		tiles = currentPlayer.generateMoves(currentPlayer.getCurrentTile(), dieValue);

		return tiles;
	}
	}

	public Connection connectTiles(Tile tileOne, Tile tileTwo) throws InvalidInputException
	{
		if(!(getTiles().contains(tileOne)) || !(getTiles().contains(tileTwo)))
		{
			throw new InvalidInputException("There is no tile in that space.");
		}
		else if(checkAdjacentTiles(tileOne, tileTwo) == false)
		{
			throw new InvalidInputException("The two tiles are not adjacent thus they cannot have a connection.");
		}
		
		Connection connector = new Connection(this);
		connector.addTile(tileOne);
		connector.addTile(tileTwo);
		
		return connector;
	}
	
	//Helper Method
	public boolean checkAdjacentTiles(Tile tile1, Tile tile2)
	{
		int xOne = tile1.getX();
		int xTwo = tile1.getX();
		int yOne = tile1.getY();
		int yTwo = tile1.getY();
		boolean adjacent = true;
		if(Math.abs(xOne - xTwo) > 1)
		{
			adjacent = false;
		}
		if(Math.abs(yOne - yTwo) > 1)
		{
			adjacent = false;
		}
		if(Math.abs(yOne - yTwo) == 1 && Math.abs(xOne - xTwo) == 1)
		{
			adjacent = false;
		}
		

		return adjacent;
	}
	
	public Connection deleteConnection(Connection connector)
	{
		removeConnection(connector);
		connector.delete();
		
		return connector;
	}
}

class Player {
  color { RED{} BLUE{} GREEN{} YELLOW{} }
  1 -> 0..1 Tile startingTile;
  0..4 -> 0..1 Tile currentTile;
  unique Integer number;
  Integer turnsUntilActive = 0;
	playerStatus { 
	    Active {
	      loseTurns(int n) [n>0] / {
	        setTurnsUntilActive(getTurnsUntilActive() + n);
	      }  -> Inactive; 
	    } 
	    Inactive {
	      takeTurn() [getTurnsUntilActive() > 1] / { 
	    setTurnsUntilActive(getTurnsUntilActive() - 1);
	 }  -> Inactive; 
	      takeTurn() [getTurnsUntilActive() <= 1] / {
	        setTurnsUntilActive(0);
	      }  -> Active; 
	      loseTurns(int n) [n>0] / {
	        setTurnsUntilActive(getTurnsUntilActive() + n);
	      }  -> Inactive; 
	    } 
	  }
  

	public List<Tile> generateMoves(int number){
        Tile origin = this.getCurrentTile();
        List<Tile> neighbours = origin.getNeighbours(null, number);
        return neighbours;
    }
	
  public List<Tile> getNeighbours(Tile prev, int number){
    List<Tile> neighbours = new ArrayList<>();
    List<Connection> connections = new ArrayList<>();
    if(number == 0){
      neighbours.add(this);
      return neighbours;
    }
    for(Connection c : this.getConnections()){
      if(!c.getTiles().contains(prev)){
        connections.add(c);
      }
    }
    for(Connection c: connections){
      List<Tile> ts = c.getTiles();
      int ind = 0;
      if(ts.size() != 1){
    	  ind = ts.indexOf(this)==0 ? 1:0;
      }

      Tile t = ts.get(ind);
      List<Tile> ns = t.getNeighbours(this, number-1);
      neighbours.addAll(ns);
    }
    return neighbours;
  }
}

class Tile {
  abstract;

  2 tiles -- 0..4 Connection connections;
  Integer x;
  Integer y;
  Boolean hasBeenVisited = false;
  
  public abstract void land();
  
  
  
}

class ActionTile {
  isA Tile;

  immutable Integer inactivityPeriod;
  Integer turnsUntilActive= 0;
  
  	public void land() {
		// Get the game that this tile is a part of
		Game currentGame = this.getGame();
		// Get the player that wants to move to the tile
		Player currentPlayer = currentGame.getCurrentPlayer();
		// Set the current tile to this tile
		currentPlayer.setCurrentTile(this);

		// Get increase the index of the current player by one
		int nextPlayerIndex = currentGame.indexOfPlayer(currentPlayer) + 1;
		// Loop back if it is the last player
		nextPlayerIndex = nextPlayerIndex % currentGame.numberOfPlayers();
		// Get the next player
		Player nextPlayer = currentGame.getPlayer(nextPlayerIndex);
		// Set the next player as the current player
		currentGame.setCurrentPlayer(nextPlayer);

		this.setHasBeenVisited(true);
		
		Deck deck = currentGame.getDeck();
		ActionCard currentCard = deck.getCurrentCard();
		//TODO check that this method works
		Mode mode = currentCard.getActionCardGameMode();

		currentGame.setMode(mode);
	}
  
}

class NormalTile {
  isA Tile;
  
  	public void land() {
		// Get the game that this tile is a part of
		Game currentGame = this.getGame();
		// Get the player that wants to move to the tile
		Player currentPlayer = currentGame.getCurrentPlayer();
		// Set the current tile to this tile
		currentPlayer.setCurrentTile(this);
		
		// Get increase the index of the current player by one
		int nextPlayerIndex = currentGame.indexOfPlayer(currentPlayer) + 1;
		// Loop back if it is the last player
		nextPlayerIndex = nextPlayerIndex % currentGame.numberOfPlayers();
		// Get the next player
		Player nextPlayer = currentGame.getPlayer(nextPlayerIndex);
		// Set the next player as the current player
		currentGame.setCurrentPlayer(nextPlayer);
		
		this.setHasBeenVisited(true);
		
		currentGame.setMode(Mode.GAME);
	}
  
}

class WinTile {
  isA Tile;
  
	public void land() {
		// Get the game that this tile is a part of
		Game currentGame = this.getGame();
		// Get the player that wants to move to the tile
		Player currentPlayer = currentGame.getCurrentPlayer();
		// Set the current tile to this tile
		currentPlayer.setCurrentTile(this);

		// Get increase the index of the current player by one
		int nextPlayerIndex = currentGame.indexOfPlayer(currentPlayer) + 1;
		// Loop back if it is the last player
		nextPlayerIndex = nextPlayerIndex % currentGame.numberOfPlayers();
		// Get the next player
		Player nextPlayer = currentGame.getPlayer(nextPlayerIndex);
		// Set the next player as the current player
		currentGame.setCurrentPlayer(nextPlayer);

		this.setHasBeenVisited(true);
		
		TileOApplication.getDesignPanel().refresh();
		TileOApplication.getDesignPanel().showMessage("You have found the hidden tile and won the game, good job big boy!");
		TileOApplication.getCurrentGame().setMode(Game.Mode.GAME_WON);
		TileOApplication.deleteGame();

		currentGame.setMode(Mode.GAME_WON);
	}
  
}

class Connection {
}

class Deck {
  1 <@>- 0..32 ActionCard cards;
  1 -> 0..1 ActionCard currentCard;
  public void clearDeck(){
	  cards.clear();
  }
}

class ActionCard {
public abstract void changeGameModeToActionCard();
  abstract;

  immutable String instructions;
}

class RollDieActionCard {
  isA ActionCard;
  //Angel
   public List<Tile> play(){
	  List<Tile> tiles = new ArrayList<Tile>();
	  Game game = this.getDeck().getGame();
	  
	  //TODO Check this method works
	  tiles = game.rollDie();
	  
	  return tiles;
  	}
}

class ConnectTilesActionCard {
  isA ActionCard;
  //Angel
    public void play(Tile tile1, Tile tile2) throws InvalidInputException{
	  Game game = this.getDeck().getGame();
	  
	  //TODO Check this method works
	  game.connectTiles(tile1, tile2);
  	}
}

class RemoveConnectionActionCard {
  isA ActionCard;
  //Angel
  	public void play(Connection aConnection) throws InvalidInputException{
	  Game game = this.getDeck().getGame();
	  
	  //TODO Check this method works
	  game.removeConnection(aConnection);
  	}
}

class TeleportActionCard {
  isA ActionCard;
  //Angel
    public void play(Tile tile) throws InvalidInputException{ 
	  	//TODO Check if methods work.
	  	tile.land();
  	}
}

class LoseTurnActionCard {
  isA ActionCard;
}

class Die {
}
