namespace ca.mcgill.ecse223.tileo.model;

class TileO {
  1 <@>- * Game games;
  1 -> 0..1 Game currentGame;
}

class Game {
  mode { DESIGN{} GAME{} GAME_WON{} GAME_ROLLDIEACTIONCARD{} GAME_CONNECTTILESACTIONCARD{} GAME_REMOVECONNECTIONACTIONCARD{} GAME_TELEPORTACTIONCARD{} GAME_LOSETURNACTIONCARD{} GAME_CHOOSEMOVEACTIONCARD{} }
  1 <@>- 2..4 Player players;
  1 <@>- * Tile tiles;
  1 <@>- * Connection connections;
  1 <@>- 1 Deck deck;
  1 <@>- 1 Die die;
  1 -> 0..1 Player currentPlayer;
  1 -> 0..1 WinTile winTile;
  const Integer SpareConnectionPieces = 32;
  Integer currentConnectionPieces;
  const Integer NumberOfActionCards = 32;
  
	public ArrayList<Tile> rollDie() {
		// List of tiles to return that represents possible moves
		ArrayList<Tile> tiles = new ArrayList<Tile>();
		// 'this' is the game
		Die die = this.getDie();

		// roll the die
		int dieValue = die.roll();
		
		// Get the current player
		Player currentPlayer = this.getCurrentPlayer();

		//TODO Check getPossibleMoves is implemented
		// Tiles is a list of possible moves the current player can make based
		// on their die role
		tiles = currentPlayer.generateMoves(currentPlayer.getCurrentTile(), dieValue);

		return tiles;
	
	}
	
	public List<Tile> rollDie(int dieValue) {
		// List of tiles to return that represents possible moves
		List<Tile> tiles = new ArrayList<Tile>();
		// 'this' is the game
		Die die = this.getDie();
		
		// Get the current player
		Player currentPlayer = this.getCurrentPlayer();
		TileOApplication.refreshDie(dieValue);
		//TODO Check getPossibleMoves is implemented
		// Tiles is a list of possible moves the current player can make based
		// on their die role
		tiles = currentPlayer.generateMoves(dieValue);

		return tiles;
	}

	public Connection connectTiles(Tile tileOne, Tile tileTwo) throws InvalidInputException
	{
		if(!(getTiles().contains(tileOne)) || !(getTiles().contains(tileTwo)))
		{
			throw new InvalidInputException("There is no tile in that space.");
		}
		else if(checkAdjacentTiles(tileOne, tileTwo) == false)
		{
			throw new InvalidInputException("The two tiles are not adjacent thus they cannot have a connection.");
		}
		
		Connection connector = new Connection(this);
		connector.addTile(tileOne);
		connector.addTile(tileTwo);
		
		return connector;
	}
	
	public boolean checkAdjacentTiles(Tile tile1, Tile tile2)
	{
		int xOne = tile1.getX();
		int xTwo = tile2.getX();
		int yOne = tile1.getY();
		int yTwo = tile2.getY();
		boolean adjacent = false;
		if((Math.abs(xOne - xTwo) == 1) && (yOne == yTwo));
		{
			adjacent = true;
		}
		if((Math.abs(yOne - yTwo) == 1) && (xOne == xTwo));
		{
			adjacent = true;
		}
		return adjacent;
	}
	
	public Connection deleteConnection(Connection connector)
	{
		removeConnection(connector);
		connector.delete();
		
		return connector;
	}
}

class Player {
  color { RED{} BLUE{} GREEN{} YELLOW{} }
  1 -> 0..1 Tile startingTile;
  0..4 -> 0..1 Tile currentTile;
  unique Integer number;
  Integer turnsUntilActive = 0;
	playerStatus { 
	    Active {
	      loseTurns(int n) [n>0] / {
	        setTurnsUntilActive(getTurnsUntilActive() + n);
	      }  -> Inactive; 
	    } 
	    Inactive {
	      takeTurn() [getTurnsUntilActive() > 1] / { 
	    setTurnsUntilActive(getTurnsUntilActive() - 1);
	 }  -> Inactive; 
	      takeTurn() [getTurnsUntilActive() <= 1] / {
	        setTurnsUntilActive(0);
	      }  -> Active; 
	      loseTurns(int n) [n>0] / {
	        setTurnsUntilActive(getTurnsUntilActive() + n);
	      }  -> Inactive; 
	    } 
	  }
  

	public List<Tile> generateMoves(int number){
        Tile origin = this.getCurrentTile();
        List<Tile> neighbours = origin.getNeighbours(null, number);
        return neighbours;
    }
	/**********************************************/
	/**PRETTY SURE THIS METHOD SHOULDN'T BE HERE***/
  public List<Tile> getNeighbours(Tile prev, int number){
    List<Tile> neighbours = new ArrayList<>();
    List<Connection> connections = new ArrayList<>();
    if(number == 0){
      neighbours.add(this);
      return neighbours;
    }
    for(Connection c : this.getConnections()){
      if(!c.getTiles().contains(prev)){
        connections.add(c);
      }
    }
    for(Connection c: connections){
      List<Tile> ts = c.getTiles();
      int ind = 0;
      if(ts.size() != 1){
    	  ind = ts.indexOf(this)==0 ? 1:0;
      }

      Tile t = ts.get(ind);
      List<Tile> ns = t.getNeighbours(this, number-1);
      neighbours.addAll(ns);
    }
    return neighbours;
  }
}

class Tile {
  abstract;

  2 tiles -- 0..4 Connection connections;
  Integer x;
  Integer y;
  Boolean hasBeenVisited = false;
  
  public abstract void land();

}

class ActionTile {
  isA Tile;

  immutable Integer inactivityPeriod;
  Integer turnsUntilActive= 0;
  
  	public void land() {
		// Get the game that this tile is a part of
		Game currentGame = this.getGame();
		// Get the player that wants to move to the tile
		Player currentPlayer = currentGame.getCurrentPlayer();
		// Set the current tile to this tile
		currentPlayer.setCurrentTile(this);
		
		currentPlayer.takeTurn();

		this.setHasBeenVisited(true);
		
		Deck deck = currentGame.getDeck();
		ActionCard currentCard = deck.getCurrentCard();
		
		currentCard.changeGameModeToActionCard();
		
		deactivate();
	}
	
	/**********************************************/
	/**THOMAS THINKS DEACTIVATE() AND TAKETURN() **/
	/**SHOULD BE ADDED HERE ***********************/
  
}

class NormalTile {
  isA Tile;
  
    /**********************************************/
    /**THIS METHOD DOES NOT MATCH THE ONE**********/
    /**CURRENTLY IN THE JAVA CODE *****************/
  	public void land() {
		// Get the game that this tile is a part of
		Game currentGame = this.getGame();
		// Get the player that wants to move to the tile
		Player currentPlayer = currentGame.getCurrentPlayer();
		// Set the current tile to this tile
		currentPlayer.setCurrentTile(this);
		
		// Get increase the index of the current player by one
		int nextPlayerIndex = currentGame.indexOfPlayer(currentPlayer) + 1;
		// Loop back if it is the last player
		nextPlayerIndex = nextPlayerIndex % currentGame.numberOfPlayers();
		// Get the next player
		Player nextPlayer = currentGame.getPlayer(nextPlayerIndex);
		// Set the next player as the current player
		currentGame.setCurrentPlayer(nextPlayer);
		
		this.setHasBeenVisited(true);
		
		currentGame.setMode(Mode.GAME);
	}
	/**********************************************/
    /**THOMAS THINKS LAND(RECT) SHOULD BE ADDEDTOO*/
  
}

class WinTile {
  isA Tile;
  
	// TODO
	public void land() {
		// Get the game that this tile is a part of
		Game currentGame = this.getGame();
		// Get the player that wants to move to the tile
		Player currentPlayer = currentGame.getCurrentPlayer();
		// Set the current tile to this tile
		currentPlayer.setCurrentTile(this);

		//TODO CHECK THIS METHOD
		currentPlayer.takeTurn();
		
		// Get increase the index of the current player by one
		int nextPlayerIndex = currentGame.indexOfPlayer(currentPlayer) + 1;
		// Loop back if it is the last player
		nextPlayerIndex = nextPlayerIndex % currentGame.numberOfPlayers();
		// Get the next player
		Player nextPlayer = currentGame.getPlayer(nextPlayerIndex);
		// Set the next player as the current player
		currentGame.setCurrentPlayer(nextPlayer);

		this.setHasBeenVisited(true);
		
		TileOApplication.getGamePage().refresh();
		TileOApplication.getGamePage().showMessage("You have found the hidden tile and won the game, good job big boy!");
		TileOApplication.getCurrentGame().setMode(Game.Mode.GAME_WON);
		TileOApplication.deleteGame();

		currentGame.setMode(Mode.GAME_WON);
	}
  
}

class Connection {
}

class Deck {
  1 <@>- 0..32 ActionCard cards;
  1 -> 0..1 ActionCard currentCard;
  public void clearDeck(){
	  cards.clear();
  }
  
  public void shuffle() {
	if(!hasCards()){
		throw new RuntimeException("Unable to shuffle empty Deck");
	}
	//Random
    Random rand = new Random();
    
    List<ActionCard> temp = cards;
    Collections.shuffle(temp);
    //shuffle the array list called 'cards'
    Collections.shuffle(cards, rand);
	//After shuffle set the current card to the first card in the stack
	currentCard = getCard(0);
  }
}

class ActionCard {
public abstract void changeGameModeToActionCard();
  abstract;

  immutable String instructions;
}

class RollDieActionCard {
  isA ActionCard;
  //Angel
   public List<Tile> play(){
	  List<Tile> tiles = new ArrayList<Tile>();
	  Game game = this.getDeck().getGame();
	  
	  //TODO Check this method works
	  tiles = game.rollDie();
	  
	  return tiles;
   }
   
  public void changeGameModeToActionCard(){
	  Deck deck = this.getDeck();
	  Game game = deck.getGame();
	  game.setMode(Mode.GAME_ROLLDIEACTIONCARD);
  }
}

class ConnectTilesActionCard {
  isA ActionCard;
  //Angel
    public void play(Tile tile1, Tile tile2) throws InvalidInputException{
	  Game game = this.getDeck().getGame();
	  
	  //TODO Check this method works
	  game.connectTiles(tile1, tile2);
	  game.setMode(Mode.GAME);
	  System.out.println("Mode changed");
  	}
  	
  public void changeGameModeToActionCard(){
	  Deck deck = this.getDeck();
	  Game game = deck.getGame();
	  game.setMode(Mode.GAME_CONNECTTILESACTIONCARD);
  }
}

class RemoveConnectionActionCard {
  isA ActionCard;
  //Angel
  	public void play(Connection aConnection) throws InvalidInputException{
	  Game game = this.getDeck().getGame();
	  
	  //TODO Check this method works
	  game.removeConnection(aConnection);
	  game.setMode(Mode.GAME);
  	}
  	
  public void changeGameModeToActionCard(){
	  Deck deck = this.getDeck();
	  Game game = deck.getGame();
	  game.setMode(Mode.GAME_REMOVECONNECTIONACTIONCARD);
  }
}

class TeleportActionCard {
  isA ActionCard;
  //Angel
    public void play(Tile tile) throws InvalidInputException{ 
	  	//TODO Check if methods work.
	  	tile.land();
  	}
  
  public void changeGameModeToActionCard(){
	  Deck deck = this.getDeck();
	  Game game = deck.getGame();
	  game.setMode(Mode.GAME_TELEPORTACTIONCARD);
  }
}

class ChooseMoveActionCard {
	isA ActionCard;
  public List<Tile> play(int n){
	  List<Tile> tiles = new ArrayList<Tile>();
	  Game game = this.getDeck().getGame();
	  game.setMode(Game.Mode.GAME_CHOOSEMOVEACTIONCARD);
	  
	  //TODO Check this method works
	  tiles = game.rollDie();
	  
	  return tiles;
  }
  
  public void changeGameModeToActionCard(){
	  Deck deck = this.getDeck();
	  Game game = deck.getGame();
	  game.setMode(Mode.GAME_ROLLDIEACTIONCARD);
  }
}

class LoseTurnActionCard {
  isA ActionCard;
  public void changeGameModeToActionCard(){
	  Deck deck = this.getDeck();
	  Game game = deck.getGame();
	  game.setMode(Mode.GAME_LOSETURNACTIONCARD);
  }
  
  public void play(){
	  Game game = this.getDeck().getGame();
	  Player player = game.getCurrentPlayer();
	  player.loseTurns(1);
  }
}

class Die {
	public int roll() {
    // Thomas
	// Return a random die roll, [1-6]
		// Default value
		int dieValue = 0;
		Random rand = new Random();
		// Get a random value between 1 and 6 inclusive
		dieValue = rand.nextInt(6) + 1;
		//
		System.out.println("Roll value " + dieValue);
		return dieValue;
	}
}
